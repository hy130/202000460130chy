#include <iostream>
#include<Windows.h>


using namespace std;

#define u32      unsigned long
#define u8       unsigned char

typedef class TimeCounter
{
public:
	TimeCounter(void)
	{
		QueryPerformanceFrequency(&CPUClock);
	}

private:
	LARGE_INTEGER startTime;

	LARGE_INTEGER endTime;

	LARGE_INTEGER CPUClock;

public:
	double timeInterval;

public:
	void start()
	{
		QueryPerformanceCounter(&startTime);
	}
	void end()
	{
		QueryPerformanceCounter(&endTime);

		timeInterval = ((double)endTime.QuadPart - (double)startTime.QuadPart) / (double)CPUClock.QuadPart;
	}
}TC;

//u8 key[16] = {
//	0xd6,0x90,0xe9,0xfe,0xcc,0xe1,0x3d,0xb7,0x16,0xb6,0x14,0xc2,0x28,0xfb,0x2c,0x05
//};
u8 key[16] = { 0x01, 0x23, 0x45, 0x67, 0x89, 0xAB, 0xCD, 0xEF, 0xFE, 0xDC, 0xBA, 0x98, 0x76, 0x54, 0x32, 0x10 };

//u32 m[4] = {
//	0xa3b1bac1, 0x56aa3351, 0x677d9191, 0xb27022d1
//};
u32 m[16] = { 0x01234567,0x89ABCDEF, 0xFEDCBA98, 0x76543210 };

u8 Sbox[256] = {
	0xd6,0x90,0xe9,0xfe,0xcc,0xe1,0x3d,0xb7,0x16,0xb6,0x14,0xc2,0x28,0xfb,0x2c,0x05,
	0x2b,0x67,0x9a,0x76,0x2a,0xbe,0x04,0xc3,0xaa,0x44,0x13,0x26,0x49,0x86,0x06,0x99,
	0x9c,0x42,0x50,0xf4,0x91,0xef,0x98,0x7a,0x33,0x54,0x0b,0x43,0xed,0xcf,0xac,0x62,
	0xe4,0xb3,0x1c,0xa9,0xc9,0x08,0xe8,0x95,0x80,0xdf,0x94,0xfa,0x75,0x8f,0x3f,0xa6,
	0x47,0x07,0xa7,0xfc,0xf3,0x73,0x17,0xba,0x83,0x59,0x3c,0x19,0xe6,0x85,0x4f,0xa8,
	0x68,0x6b,0x81,0xb2,0x71,0x64,0xda,0x8b,0xf8,0xeb,0x0f,0x4b,0x70,0x56,0x9d,0x35,
	0x1e,0x24,0x0e,0x5e,0x63,0x58,0xd1,0xa2,0x25,0x22,0x7c,0x3b,0x01,0x21,0x78,0x87,
	0xd4,0x00,0x46,0x57,0x9f,0xd3,0x27,0x52,0x4c,0x36,0x02,0xe7,0xa0,0xc4,0xc8,0x9e,
	0xea,0xbf,0x8a,0xd2,0x40,0xc7,0x38,0xb5,0xa3,0xf7,0xf2,0xce,0xf9,0x61,0x15,0xa1,
	0xe0,0xae,0x5d,0xa4,0x9b,0x34,0x1a,0x55,0xad,0x93,0x32,0x30,0xf5,0x8c,0xb1,0xe3,
	0x1d,0xf6,0xe2,0x2e,0x82,0x66,0xca,0x60,0xc0,0x29,0x23,0xab,0x0d,0x53,0x4e,0x6f,
	0xd5,0xdb,0x37,0x45,0xde,0xfd,0x8e,0x2f,0x03,0xff,0x6a,0x72,0x6d,0x6c,0x5b,0x51,
	0x8d,0x1b,0xaf,0x92,0xbb,0xdd,0xbc,0x7f,0x11,0xd9,0x5c,0x41,0x1f,0x10,0x5a,0xd8,
	0x0a,0xc1,0x31,0x88,0xa5,0xcd,0x7b,0xbd,0x2d,0x74,0xd0,0x12,0xb8,0xe5,0xb4,0xb0,
	0x89,0x69,0x97,0x4a,0x0c,0x96,0x77,0x7e,0x65,0xb9,0xf1,0x09,0xc5,0x6e,0xc6,0x84,
	0x18,0xf0,0x7d,0xec,0x3a,0xdc,0x4d,0x20,0x79,0xee,0x5f,0x3e,0xd7,0xcb,0x39,0x48
};

// 密钥扩展算法的常数FK 
u32 FK[4] = {
	0xa3b1bac6, 0x56aa3350, 0x677d9197, 0xb27022dc
};

// 密钥扩展算法的固定参数CK 
u32 CK[32] = {
	0x00070e15, 0x1c232a31, 0x383f464d, 0x545b6269,
	0x70777e85, 0x8c939aa1, 0xa8afb6bd, 0xc4cbd2d9,
	0xe0e7eef5, 0xfc030a11, 0x181f262d, 0x343b4249,
	0x50575e65, 0x6c737a81, 0x888f969d, 0xa4abb2b9,
	0xc0c7ced5, 0xdce3eaf1, 0xf8ff060d, 0x141b2229,
	0x30373e45, 0x4c535a61, 0x686f767d, 0x848b9299,
	0xa0a7aeb5, 0xbcc3cad1, 0xd8dfe6ed, 0xf4fb0209,
	0x10171e25, 0x2c333a41, 0x484f565d, 0x646b7279
};

u32 rk[32];
static void dump_buf(u8* buf, u32 len)
{
	int i;

	printf("buf:");

	for (i = 0; i < len; i++) {
		printf("%s%02X%s", i % 16 == 0 ? "\r\n\t" : " ",
			buf[i],
			i == len - 1 ? "\r\n" : "");
	}
}

//u32* getkey() {
//	u32 keyFk[4];
//	u8 keyFk_temp[4];
//	for (int i = 0; i < 4; i++) {
//		keyFk_temp[0] = key[0 + 4 * i];
//		keyFk_temp[1] = key[1 + 4 * i];
//		keyFk_temp[2] = key[2 + 4 * i];
//		keyFk_temp[3] = key[3 + 4 * i];
//		keyFk[i] = (keyFk_temp[0] * 256 * 256 * 256 + keyFk_temp[1] * 256 * 256 + keyFk_temp[2] * 256 + keyFk_temp[3]) ^ FK[i];
//	}
//	return keyFk;
//}

u32 loopleft(u32 A1, int n) {
	u32 A = A1;
	for (int i = 0; i < n; i++) {
		if (A / 0x80000000 == 1) {
			A = A * 2;
			A = A + 1;
		}
		else {
			A = A * 2;
		}
	}
	return A;
}

u32 T_function(u32 A) {
	u32 B1;
	u32 B2;
	u32 result;
	u8 result_Sbox[4];
	//for (int i = 0; i < 4; i++) {
	//	//u8 index = (u8)(A >> i * 8);
	//	result_Sbox[i] = Sbox[index];
	//}
	u8 a[4];
	short i;
	a[0] = A / 0x1000000;
	a[1] = A / 0x10000;
	a[2] = A / 0x100;
	a[3] = A;
	u32 temp_ = Sbox[a[0]] * 256 * 256 * 256 + Sbox[a[1]] * 256 * 256 + Sbox[a[2]] * 256 + Sbox[a[3]];
	B1 = loopleft((u32)temp_, 13);
	B2 = loopleft((u32)temp_, 23);
	result = (B1 ^ B2 ^ temp_);
	return result;
}
u32 T_function1(u32 A) {
	u32 B1;
	u32 B2;
	u32 B3;
	u32 B4;
	u32 result;
	u8 result_Sbox[4];
	result_Sbox[0] = Sbox[u8(A / 0x1000000)];
	result_Sbox[1] = Sbox[u8(A / 0x10000)];
	result_Sbox[2] = Sbox[u8(A / 0x100)];
	result_Sbox[3] = Sbox[u8(A)];
	u32 temp = result_Sbox[0] * 256 * 256 * 256 + result_Sbox[1] * 256 * 256 + result_Sbox[2] * 256 + result_Sbox[3];
	B1 = loopleft((u32)temp, 2);
	B2 = loopleft((u32)temp, 10);
	B3 = loopleft((u32)temp, 18);
	B4 = loopleft((u32)temp, 24);
	result = (B1 ^ B2 ^ B3 ^ B4 ^ temp);
	return result;
}
void getkeys() {
	u32 temp[4];
	u8 keyFk_temp[4];
	for (int i = 0; i < 4; i++) {
		keyFk_temp[0] = key[0 + 4 * i];
		keyFk_temp[1] = key[1 + 4 * i];
		keyFk_temp[2] = key[2 + 4 * i];
		keyFk_temp[3] = key[3 + 4 * i];
		temp[i] = (keyFk_temp[0] * 256 * 256 * 256 + keyFk_temp[1] * 256 * 256 + keyFk_temp[2] * 256 + keyFk_temp[3]) ^ FK[i];
	}
	for (int i = 0; i < 32; i++) {
		u32 temp1 = CK[i] ^ temp[1] ^ temp[2] ^ temp[3];
		rk[i] = T_function(temp1) ^ temp[0];
		for (int i = 0; i < 3; i++) {
			temp[i] = temp[i + 1];
		}
		temp[3] = rk[i];
		cout << hex << rk[i] << endl;
	}
}
u32* encrypt(u32 m[4]) {
	getkeys();
	for (int i = 0; i < 32; i++) {
		u32 temp_X = T_function1(m[1] ^ m[2] ^ m[3] ^ rk[i]) ^ m[0];
		for (int i = 0; i < 3; i++) {
			m[i] = m[i + 1];
		}
		m[3] = temp_X;
	}
	u32 result[4];
	for (int i = 0; i < 4; i++) {
		result[i] = m[3 - i];
	}
	return result;
}
int main()
{
	TC TC1;
	TC1.start();
	u32* c = encrypt(m);
	TC1.end();
    cout << "时间:" << TC1.timeInterval << endl;
	cout << hex << c[0] << " " << c[1] << " " << c[2] << " " << c[3];
}

























#include<iostream>
#include<Windows.h>
using namespace std;

int SBOX[] = {
                0xD6, 0x90, 0xE9, 0xFE, 0xCC, 0xE1, 0x3D, 0xB7, 0x16, 0xB6, 0x14, 0xC2, 0x28, 0xFB, 0x2C, 0x05, 0x2B, 0x67, 0x9A,
                0x76, 0x2A, 0xBE, 0x04, 0xC3, 0xAA, 0x44, 0x13, 0x26, 0x49, 0x86, 0x06, 0x99, 0x9C, 0x42, 0x50, 0xF4, 0x91, 0xEF,
                0x98, 0x7A, 0x33, 0x54, 0x0B, 0x43, 0xED, 0xCF, 0xAC, 0x62, 0xE4, 0xB3, 0x1C, 0xA9, 0xC9, 0x08, 0xE8, 0x95, 0x80,
                0xDF, 0x94, 0xFA, 0x75, 0x8F, 0x3F, 0xA6, 0x47, 0x07, 0xA7, 0xFC, 0xF3, 0x73, 0x17, 0xBA, 0x83, 0x59, 0x3C, 0x19,
                0xE6, 0x85, 0x4F, 0xA8, 0x68, 0x6B, 0x81, 0xB2, 0x71, 0x64, 0xDA, 0x8B, 0xF8, 0xEB, 0x0F, 0x4B, 0x70, 0x56, 0x9D,
                0x35, 0x1E, 0x24, 0x0E, 0x5E, 0x63, 0x58, 0xD1, 0xA2, 0x25, 0x22, 0x7C, 0x3B, 0x01, 0x21, 0x78, 0x87, 0xD4, 0x00,
                0x46, 0x57, 0x9F, 0xD3, 0x27, 0x52, 0x4C, 0x36, 0x02, 0xE7, 0xA0, 0xC4, 0xC8, 0x9E, 0xEA, 0xBF, 0x8A, 0xD2, 0x40,
                0xC7, 0x38, 0xB5, 0xA3, 0xF7, 0xF2, 0xCE, 0xF9, 0x61, 0x15, 0xA1, 0xE0, 0xAE, 0x5D, 0xA4, 0x9B, 0x34, 0x1A, 0x55,
                0xAD, 0x93, 0x32, 0x30, 0xF5, 0x8C, 0xB1, 0xE3, 0x1D, 0xF6, 0xE2, 0x2E, 0x82, 0x66, 0xCA, 0x60, 0xC0, 0x29, 0x23,
                0xAB, 0x0D, 0x53, 0x4E, 0x6F, 0xD5, 0xDB, 0x37, 0x45, 0xDE, 0xFD, 0x8E, 0x2F, 0x03, 0xFF, 0x6A, 0x72, 0x6D, 0x6C,
                0x5B, 0x51, 0x8D, 0x1B, 0xAF, 0x92, 0xBB, 0xDD, 0xBC, 0x7F, 0x11, 0xD9, 0x5C, 0x41, 0x1F, 0x10, 0x5A, 0xD8, 0x0A,
                0xC1, 0x31, 0x88, 0xA5, 0xCD, 0x7B, 0xBD, 0x2D, 0x74, 0xD0, 0x12, 0xB8, 0xE5, 0xB4, 0xB0, 0x89, 0x69, 0x97, 0x4A,
                0x0C, 0x96, 0x77, 0x7E, 0x65, 0xB9, 0xF1, 0x09, 0xC5, 0x6E, 0xC6, 0x84, 0x18, 0xF0, 0x7D, 0xEC, 0x3A, 0xDC, 0x4D,
                0x20, 0x79, 0xEE, 0x5F, 0x3E, 0xD7, 0xCB, 0x39, 0x48
};


int FK[] = { 0xa3b1bac6, 0x56aa3350, 0x677d9197, 0xb27022dc };
int CK[] = {
        0x00070e15, 0x1c232a31, 0x383f464d, 0x545b6269,
        0x70777e85, 0x8c939aa1, 0xa8afb6bd, 0xc4cbd2d9,
        0xe0e7eef5, 0xfc030a11, 0x181f262d, 0x343b4249,
        0x50575e65, 0x6c737a81, 0x888f969d, 0xa4abb2b9,
        0xc0c7ced5, 0xdce3eaf1, 0xf8ff060d, 0x141b2229,
        0x30373e45, 0x4c535a61, 0x686f767d, 0x848b9299,
        0xa0a7aeb5, 0xbcc3cad1, 0xd8dfe6ed, 0xf4fb0209,
        0x10171e25, 0x2c333a41, 0x484f565d, 0x646b7279
};

typedef class TimeCounter
{
public:
    TimeCounter(void)
    {
        QueryPerformanceFrequency(&CPUClock);
    }

private:
    LARGE_INTEGER startTime;

    LARGE_INTEGER endTime;

    LARGE_INTEGER CPUClock;

public:
    double timeInterval;

public:
    void start()
    {
        QueryPerformanceCounter(&startTime);
    }
    void end()
    {
        QueryPerformanceCounter(&endTime);

        timeInterval = ((double)endTime.QuadPart - (double)startTime.QuadPart) / (double)CPUClock.QuadPart;
    }
}TC;

//S盒
void S_change(int sbox_input, int& sbox_output)
{
    sbox_output = SBOX[sbox_input];
}



//分割为32bit 四个X 四个K
//实际上是拼接
void split_int256(int int256[], int re[])
{
    for (int i = 0; i < 4; i++)
    {
        for (int j = 0; j < 4; j++)
        {
            re[i] = re[i] << 8;
            re[i] += int256[i * 4 + j];
        }
    }
}

//分割成8bit S盒输入
void split_sbox_input(int sbox_input, int re[])
{
    for (int i = 0; i < 4; i++)
    {
        re[3 - i] = sbox_input & 0xff;
        sbox_input = (unsigned int)sbox_input >> 8;
    }
}


//S盒的输出，合并为一个数
void join_sbox_output(int sbox_output_arr[], int& sbox_out)
{
    sbox_out = 0;
    for (int i = 0; i < 4; i++)
    {
        sbox_out = sbox_out << 8;
        sbox_out += sbox_output_arr[i];
    }
}

//循环左移函数
void cycle_shift_left(int target, int step, int& re)
{

    int head = (unsigned int)target >> (32 - step);
    re = (target << step) | head;
}



//循环函数
void SM4_cycle(int x0x1x2x3[], int key32)
{
    int xi = x0x1x2x3[0];
    //sbox_input=xi+1⊕xi+2⊕xi+3⊕rki
    int sbox_input = x0x1x2x3[1] ^ x0x1x2x3[2] ^ x0x1x2x3[3] ^ key32;

    int sbox_input_arr[4] = { 0 };

    split_sbox_input(sbox_input, sbox_input_arr);

    int sbox_output_arr[4] = { 0 };
    for (int i = 0; i < 4; i++)
    {
        S_change(sbox_input_arr[i], sbox_output_arr[i]);
    }

    int sbox_output = 0;
    join_sbox_output(sbox_output_arr, sbox_output);

    int y2 = 0, y10 = 0, y18 = 0, y24 = 0;

    cycle_shift_left(sbox_output, 2, y2);
    cycle_shift_left(sbox_output, 10, y10);
    cycle_shift_left(sbox_output, 18, y18);
    cycle_shift_left(sbox_output, 24, y24);


    // xi+4=sbox_output⊕y2⊕y10⊕y18⊕y24⊕xi

    int xi_4 = sbox_output ^ y2 ^ y10 ^ y18 ^ y24 ^ xi;

    x0x1x2x3[0] = x0x1x2x3[1];
    x0x1x2x3[1] = x0x1x2x3[2];
    x0x1x2x3[2] = x0x1x2x3[3];
    x0x1x2x3[3] = xi_4;
}

void key_cycle(int k0k1k2k3[], int re[], int i)
{
    int k0 = k0k1k2k3[0];
    int k1 = k0k1k2k3[1];
    int k2 = k0k1k2k3[2];
    int k3 = k0k1k2k3[3];

    int ki = k0;
    //sbox_input=ki+1⊕ki+2⊕ki+3⊕cki
    int sbox_input = k1 ^ k2 ^ k3 ^ CK[i];

    int sbox_input_arr[4] = { 0 };

    split_sbox_input(sbox_input, sbox_input_arr);

    int sbox_output_arr[4] = { 0 };
    for (int j = 0; j < 4; j++)
    {
        S_change(sbox_input_arr[j], sbox_output_arr[j]);
    }

    int sbox_output = 0;
    join_sbox_output(sbox_output_arr, sbox_output);


    int y13 = 0, y23 = 0;

    cycle_shift_left(sbox_output, 13, y13);
    cycle_shift_left(sbox_output, 23, y23);

    //rki=ki+4=sbox_output⊕y13⊕y23⊕ki

    int ki_4 = sbox_output ^ y13 ^ y23 ^ ki;

    re[i] = ki_4;

    k0k1k2k3[0] = k0k1k2k3[1];
    k0k1k2k3[1] = k0k1k2k3[2];
    k0k1k2k3[2] = k0k1k2k3[3];
    k0k1k2k3[3] = ki_4;


}

void key_generate(int key[], int re[])
{
    int k0k1k2k3[4] = { 0 };
    split_int256(key, k0k1k2k3);
    k0k1k2k3[0] = k0k1k2k3[0] ^ FK[0];
    k0k1k2k3[1] = k0k1k2k3[1] ^ FK[1];
    k0k1k2k3[2] = k0k1k2k3[2] ^ FK[2];
    k0k1k2k3[3] = k0k1k2k3[3] ^ FK[3];


    for (int i = 0; i < 32; i++)
    {
        key_cycle(k0k1k2k3, re, i);
    }
}

void join_output(int x0x1x2x3[], int output[])
{
    for (int i = 0; i < 4; i++)
    {
        for (int j = 0; j < 4; j++)
        {
            output[15 - 4 * i - j] = x0x1x2x3[i] & 0xff;
            x0x1x2x3[i] = (unsigned int)x0x1x2x3[i] >> 8;
        }
    }
}


void SM4_encrypt(int key[], int plaintext[], int output[])
{

    //生成密钥
    int rki[32] = { 0 };
    key_generate(key, rki);

    int x0x1x2x3[4] = { 0 };
    split_int256(plaintext, x0x1x2x3);

    for (int i = 0; i < 32; i++)
    {
        SM4_cycle(x0x1x2x3, rki[i]);
    }
    join_output(x0x1x2x3, output);
}


int main()
{
    int key[16] = { 0x01, 0x23, 0x45, 0x67, 0x89, 0xAB, 0xCD, 0xEF, 0xFE, 0xDC, 0xBA, 0x98, 0x76, 0x54, 0x32, 0x10 };

    int plaintext[16] = { 0x01, 0x23, 0x45, 0x67, 0x89, 0xAB, 0xCD, 0xEF, 0xFE, 0xDC, 0xBA, 0x98, 0x76, 0x54, 0x32, 0x10 };

    int output[16] = { 0 };

    TC TC1;
    TC1.start();
    SM4_encrypt(key, plaintext, output);
    TC1.end();

    cout << "时间:" << TC1.timeInterval << endl;
    cout << "加密结果:";
    for (int i = 0; i < 16; i++)
    {
        cout << hex << output[i] << " ";
    }
}




























#include<stdio.h>
#define u8 unsigned char
#define u32 unsigned long

// S盒
const u8 Sbox[256] = {
	0xd6,0x90,0xe9,0xfe,0xcc,0xe1,0x3d,0xb7,0x16,0xb6,0x14,0xc2,0x28,0xfb,0x2c,0x05,
	0x2b,0x67,0x9a,0x76,0x2a,0xbe,0x04,0xc3,0xaa,0x44,0x13,0x26,0x49,0x86,0x06,0x99,
	0x9c,0x42,0x50,0xf4,0x91,0xef,0x98,0x7a,0x33,0x54,0x0b,0x43,0xed,0xcf,0xac,0x62,
	0xe4,0xb3,0x1c,0xa9,0xc9,0x08,0xe8,0x95,0x80,0xdf,0x94,0xfa,0x75,0x8f,0x3f,0xa6,
	0x47,0x07,0xa7,0xfc,0xf3,0x73,0x17,0xba,0x83,0x59,0x3c,0x19,0xe6,0x85,0x4f,0xa8,
	0x68,0x6b,0x81,0xb2,0x71,0x64,0xda,0x8b,0xf8,0xeb,0x0f,0x4b,0x70,0x56,0x9d,0x35,
	0x1e,0x24,0x0e,0x5e,0x63,0x58,0xd1,0xa2,0x25,0x22,0x7c,0x3b,0x01,0x21,0x78,0x87,
	0xd4,0x00,0x46,0x57,0x9f,0xd3,0x27,0x52,0x4c,0x36,0x02,0xe7,0xa0,0xc4,0xc8,0x9e,
	0xea,0xbf,0x8a,0xd2,0x40,0xc7,0x38,0xb5,0xa3,0xf7,0xf2,0xce,0xf9,0x61,0x15,0xa1,
	0xe0,0xae,0x5d,0xa4,0x9b,0x34,0x1a,0x55,0xad,0x93,0x32,0x30,0xf5,0x8c,0xb1,0xe3,
	0x1d,0xf6,0xe2,0x2e,0x82,0x66,0xca,0x60,0xc0,0x29,0x23,0xab,0x0d,0x53,0x4e,0x6f,
	0xd5,0xdb,0x37,0x45,0xde,0xfd,0x8e,0x2f,0x03,0xff,0x6a,0x72,0x6d,0x6c,0x5b,0x51,
	0x8d,0x1b,0xaf,0x92,0xbb,0xdd,0xbc,0x7f,0x11,0xd9,0x5c,0x41,0x1f,0x10,0x5a,0xd8,
	0x0a,0xc1,0x31,0x88,0xa5,0xcd,0x7b,0xbd,0x2d,0x74,0xd0,0x12,0xb8,0xe5,0xb4,0xb0,
	0x89,0x69,0x97,0x4a,0x0c,0x96,0x77,0x7e,0x65,0xb9,0xf1,0x09,0xc5,0x6e,0xc6,0x84,
	0x18,0xf0,0x7d,0xec,0x3a,0xdc,0x4d,0x20,0x79,0xee,0x5f,0x3e,0xd7,0xcb,0x39,0x48
};

// 密钥扩展算法的常数FK 
const u32 FK[4] = {
	0xa3b1bac6, 0x56aa3350, 0x677d9197, 0xb27022dc
};

// 密钥扩展算法的固定参数CK 
const u32 CK[32] = {
	0x00070e15, 0x1c232a31, 0x383f464d, 0x545b6269,
	0x70777e85, 0x8c939aa1, 0xa8afb6bd, 0xc4cbd2d9,
	0xe0e7eef5, 0xfc030a11, 0x181f262d, 0x343b4249,
	0x50575e65, 0x6c737a81, 0x888f969d, 0xa4abb2b9,
	0xc0c7ced5, 0xdce3eaf1, 0xf8ff060d, 0x141b2229,
	0x30373e45, 0x4c535a61, 0x686f767d, 0x848b9299,
	0xa0a7aeb5, 0xbcc3cad1, 0xd8dfe6ed, 0xf4fb0209,
	0x10171e25, 0x2c333a41, 0x484f565d, 0x646b7279
};

u32 functionB(u32 b); // 查S盒的函数B 
u32 loopLeft(u32 a, short length); // 循环左移函数 
u32 functionL1(u32 a); // 线性变换L
u32 functionL2(u32 a); // 线性变换L'
u32 functionT(u32 a, short mode); // 合成变换T
void extendFirst(u32 MK[], u32 K[]); // 密钥扩展算法第一步
void extendSecond(u32 RK[], u32 K[]); // 密钥扩展算法第二步
void getRK(u32 MK[], u32 K[], u32 RK[]); // 轮密钥获取算法
void iterate32(u32 X[], u32 RK[]); // 迭代算法
void reverse(u32 X[], u32 Y[]); // 反转函数 
void encryptSM4(u32 X[], u32 RK[], u32 Y[]); // 加密算法
void decryptSM4(u32 X[], u32 RK[], u32 Y[]); // 解密算法

/*
	查S盒的函数B
	参数:	u32 b
	返回值:	查S盒的结果u32 b
*/
u32 functionB(u32 b) {
	u8 a[4];
	short i;
	a[0] = b / 0x1000000;
	a[1] = b / 0x10000;
	a[2] = b / 0x100;
	a[3] = b;
	b = Sbox[a[0]] * 0x1000000 + Sbox[a[1]] * 0x10000 + Sbox[a[2]] * 0x100 + Sbox[a[3]];
	return b;
}

/*
	循环左移算法
	参数：	u32 a    length：循环左移位数
	返回值：u32 b
*/
u32 loopLeft(u32 a, short length) {
	short i;
	for (i = 0; i < length; i++) {
		a = a * 2 + a / 0x80000000;
	}
	return a;
}

/*
	密钥线性变换函数L
	参数：	u32 a
	返回值：线性变换后的u32 a
*/
u32 functionL1(u32 a) {
	return a ^ loopLeft(a, 2) ^ loopLeft(a, 10) ^ loopLeft(a, 18) ^ loopLeft(a, 24);
}

/*
	密钥线性变换函数L'
	参数：	u32 a
	返回值：移位操作后的u32 a
*/
u32 functionL2(u32 a) {
	return a ^ loopLeft(a, 13) ^ loopLeft(a, 23);
}

/*
	合成变换T
	参数：	u32 a    short mode：1表示明文的T，调用L；2表示密钥的T，调用L'
	返回值：合成变换后的u32 a
*/
u32 functionT(u32 a, short mode) {
	return mode == 1 ? functionL1(functionB(a)) : functionL2(functionB(a));
}

/*
	密钥扩展算法第一步
	参数：	MK[4]：密钥  K[4]:中间数据，保存结果	（FK[4]：常数）
	返回值：无
*/
void extendFirst(u32 MK[], u32 K[]) {
	int i;
	for (i = 0; i < 4; i++) {
		K[i] = MK[i] ^ FK[i];
	}
}

/*
	密钥扩展算法第二步
	参数：	RK[32]：轮密钥，保存结果    K[4]：中间数据 （CK[32]：固定参数）
	返回值：无
*/
void extendSecond(u32 RK[], u32 K[]) {
	short i;
	for (i = 0; i < 32; i++) {
		K[(i + 4) % 4] = K[i % 4] ^ functionT(K[(i + 1) % 4] ^ K[(i + 2) % 4] ^ K[(i + 3) % 4] ^ CK[i], 2);
		RK[i] = K[(i + 4) % 4];
	}
}

/*
	密钥扩展算法
	参数：	MK[4]：密钥     K[4]：中间数据    RK[32]：轮密钥，保存结果
	返回值：无
*/
void getRK(u32 MK[], u32 K[], u32 RK[]) {
	extendFirst(MK, K);
	extendSecond(RK, K);
}

/*
	迭代32次
	参数：	u32 X[4]：迭代对象，保存结果    u32 RK[32]：轮密钥
	返回值：无
*/
void iterate32(u32 X[], u32 RK[]) {
	short i;
	for (i = 0; i < 32; i++) {
		X[(i + 4) % 4] = X[i % 4] ^ functionT(X[(i + 1) % 4] ^ X[(i + 2) % 4] ^ X[(i + 3) % 4] ^ RK[i], 1);
	}
}

/*
	反转函数
	参数；	u32 X[4]：反转对象    u32 Y[4]：反转结果
	返回值：无
*/
void reverse(u32 X[], u32 Y[]) {
	short i;
	for (i = 0; i < 4; i++) {
		Y[i] = X[4 - 1 - i];
	}
}

/*
	加密算法
	参数：	u32 X[4]：明文    u32 RK[32]：轮密钥    u32 Y[4]：密文，保存结果
	返回值：无
*/
void encryptSM4(u32 X[], u32 RK[], u32 Y[]) {
	iterate32(X, RK);
	reverse(X, Y);
}

/*
	解密算法
	参数： 	u32 X[4]：密文    u32 RK[32]：轮密钥    u32 Y[4]：明文，保存结果
	返回值：无
*/
void decryptSM4(u32 X[], u32 RK[], u32 Y[]) {
	short i;
	u32 reverseRK[32];
	for (i = 0; i < 32; i++) {
		reverseRK[i] = RK[32 - 1 - i];
	}
	iterate32(X, reverseRK);
	reverse(X, Y);
}

/*
	测试数据：
	明文：	01234567 89abcdef fedcba98 76543210
	密钥：	01234567 89abcdef fedcba98 76543210
	密文：	681edf34 d206965e 86b3e94f 536e4246
*/
int main(void) {
	u32 X[4]; // 明文 
	u32 MK[4]; // 密钥 
	u32 RK[32]; // 轮密钥  
	u32 K[4]; // 中间数据 
	u32 Y[4]; // 密文 
	short i; // 临时变量 
	printf("明文：");
	scanf_s("%8x%8x%8x%8x", &X[0], &X[1], &X[2], &X[3]);
	printf("密钥：");
	scanf_s("%8x%8x%8x%8x", &MK[0], &MK[1], &MK[2], &MK[3]);
	printf("**************生成轮密钥*****************\n");
	getRK(MK, K, RK);
	for (i = 0; i < 32; i++) {
		printf("[%2d]：%08x    ", i, RK[i]);
		if (i % 4 == 3)	printf("\n");
	}
	printf("************** 生成密文 *****************\n");
	encryptSM4(X, RK, Y);
	printf("%08x %08x %08x %08x\n", Y[0], Y[1], Y[2], Y[3]);
	printf("************** 生成明文 *****************\n");
	decryptSM4(Y, RK, X);
	printf("%08x %08x %08x %08x\n", X[0], X[1], X[2], X[3]);
	return 0;
}
